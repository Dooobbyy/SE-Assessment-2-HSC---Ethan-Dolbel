# core/views.py
from django.shortcuts import render, redirect, get_object_or_404
from django.views.generic import TemplateView
from django.db import transaction
from django.utils.http import urlsafe_base64_decode
from django.contrib import messages
from django.views.decorators.http import require_http_methods
from django.contrib.auth.decorators import login_required
from django.contrib.auth import login, logout, authenticate, get_user_model
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm, SetPasswordForm
from django.contrib.auth.tokens import default_token_generator
from django.contrib.auth.models import User
from django.contrib.auth.backends import ModelBackend
from django.views.decorators.csrf import csrf_protect
from django.views.decorators.cache import never_cache
from django.utils.decorators import method_decorator
from django.views.generic import View
from django.http import HttpResponse, HttpResponseRedirect
from .utils import send_verification_email, send_password_reset_email
from .models import Property, Transaction, Scenario, Tenant, WeeklyMortgageChange, WeeklyRentChange
from .forms import PropertyForm, TransactionForm, BulkTransactionForm, ValuePredictionForm, ScenarioComparisonForm, ScenarioForm, SecureUserCreationForm, SecureAuthenticationForm, WeeklyRentChangeForm, WeeklyMortgageChangeForm, TenantForm
from datetime import date, timedelta, timezone
from dateutil.relativedelta import relativedelta
from django.utils.http import urlsafe_base64_decode
from django.db.models import Sum, Q
from decimal import Decimal
import calendar
import logging

TRANSACTION_TYPE_CHOICES = [
    ('rental_income', 'Rental Income'),
    ('additional_income', 'Additional Income'),
    ('other_income', 'Other Income'),
    ('maintenance', 'Maintenance'),
    ('taxes', 'Property Taxes'),
    ('insurance', 'Insurance'),
    ('other_expense', 'Other Expense'),
]

logger = logging.getLogger(__name__)
User = get_user_model()

@csrf_protect
@never_cache
def register(request):
    if request.method == 'POST':
        form = SecureUserCreationForm(request.POST)
        if form.is_valid():
            user = form.save() # Save the user first
            # --- Send verification email ---
            # The user is created with is_verified=False by default (from the model)
            # The verification token should be generated by the model's save method
            # or explicitly here before sending the email.
            # Ensure the user object passed to send_verification_email has a token.
            if hasattr(user, 'generate_verification_token'):
                 # Generate token if the method exists and it's not generated on save
                 if not user.verification_token:
                     user.generate_verification_token()
            # Pass the user object (which should now have a token) and the request
            if send_verification_email(user, request): # Pass request for full URL
                 # Inform user that verification is required
                 messages.success(
                     request,
                     'Registration successful! A verification email has been sent '
                     'to your email address. Please check your inbox and click the '
                     'link to verify your account before logging in.'
                 )
                 logger.info(f"Registration successful for user '{user.username}'. Verification email sent to {user.email}.")
            else:
                 # Log the failure, inform user
                 messages.warning(
                     request,
                     'Registration successful, but we could not send the verification '
                     'email. Please contact support or try again later.'
                 )
                 logger.error(f"Failed to send verification email for user '{user.username}' ({user.email}).")
            # -------------------------------
            return redirect('login') # Redirect to login page
    else:
        form = SecureUserCreationForm()
    return render(request, 'registration/register.html', {'form': form})

# --- Updated Login View ---
@csrf_protect
@never_cache
def login_view(request):
    # Redirect authenticated users away from the login page
    if request.user.is_authenticated:
        return redirect('dashboard') # Or wherever you want them to go

    if request.method == 'POST':
        # Use the standard AuthenticationForm. The actual username/email check
        # will be handled by the custom backend.
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            # The 'username' field in the form will contain either the username or email
            identifier = form.cleaned_data.get('username') # This is the input from the form's first field
            password = form.cleaned_data.get('password')

            # Authenticate using the configured backends (including your custom one)
            user = authenticate(request, username=identifier, password=password)

            if user is not None:
                # --- Check if the user's email is verified ---
                # Assuming your CustomUser model has an 'is_verified' field
                if not getattr(user, 'is_verified', True): # Default to True if field doesn't exist for safety during transition
                     messages.error(
                         request,
                         'Please verify your email address before logging in. '
                         'Check your inbox for the verification email.'
                     )
                     logger.warning(f"Login attempt by unverified user: {identifier}")
                     # Re-render the login form, preserving the entered username
                     return render(request, 'registration/login.html', {'form': form})

                # --- Successful authentication ---
                login(request, user)
                messages.success(request, f'Welcome back, {user.username}!')
                logger.info(f"Successful login for user: {user.username} (ID: {user.id})")

                # Redirect to the next page or dashboard
                next_page = request.GET.get('next') # Get the 'next' parameter
                if next_page:
                    # Ensure the next_page is safe to prevent open redirects
                    # (Django's login view handles this, but good to be aware)
                    return redirect(next_page)
                else:
                    return redirect('dashboard') # Default redirect

            else:
                # Authentication failed (user not found or password incorrect)
                # The standard form error message might be "Please enter a correct username and password."
                # You can add a more specific message if needed.
                messages.error(request, 'Invalid username/email or password.')
                logger.warning(f"Failed login attempt for identifier: {identifier}")
        else:
            # Form validation failed (e.g., fields missing)
            messages.error(request, 'Invalid username/email or password.')
    else:
        # GET request - display the empty form
        form = AuthenticationForm()

    # Render the login template with the form (either empty or with errors)
    return render(request, 'registration/login.html', {'form': form})

@require_http_methods(["GET"])
def verify_email(request):
    token = request.GET.get('token')
    if not token:
        messages.error(request, "Invalid verification link.")
        return redirect('login')

    try:
        user = User.objects.get(verification_token=token)
    except User.DoesNotExist:
        messages.error(request, "Invalid or expired verification link.")
        return redirect('login')

    # Verify the user
    user.is_verified = True
    user.verification_token = None
    user.save(update_fields=['is_verified', 'verification_token'])

    messages.success(request, "Email verified successfully! You can now log in.")
    logger.info(f"Email verified for user: {user.username}")
    return redirect('login')

def forgot_password(request):
    if request.method == 'POST':
        email = request.POST.get('email', '').strip()
        if not email:
             messages.error(request, "Please enter your email address.")
             return render(request, 'registration/forgot_password.html')

        try:
            user = User.objects.get(email__iexact=email)
        except User.DoesNotExist:
            messages.info(request, "If an account exists with that email, a password reset link has been sent.")
            logger.info(f"Password reset requested for non-existent email: {email}")
            return render(request, 'registration/forgot_password.html')

        # Generate and send reset token using the utility
        if send_password_reset_email(user, request):
             messages.info(request, "If an account exists with that email, a password reset link has been sent.")
             logger.info(f"Password reset email sent to user: {user.username}")
        else:
             messages.error(request, "An error occurred while sending the email. Please try again later.")
             logger.error(f"Failed to send password reset email to user: {user.username}")

        return render(request, 'registration/forgot_password.html')

    return render(request, 'registration/forgot_password.html')

@require_http_methods(["GET", "POST"])
def reset_password(request):
    token = request.GET.get('token') or request.POST.get('token')
    if not token:
        messages.error(request, "Invalid or missing password reset token.")
        return redirect('login')

    try:
        user = User.objects.get(reset_token=token)
    except User.DoesNotExist:
        messages.error(request, "Invalid or expired password reset link.")
        return redirect('login')

    # Check token validity using the model method
    if not user.is_reset_token_valid():
        messages.error(request, "This password reset link has expired.")
        return redirect('login')

    if request.method == 'POST':
        new_password1 = request.POST.get('new_password1', '')
        new_password2 = request.POST.get('new_password2', '')

        if new_password1 != new_password2:
            messages.error(request, "The two password fields didn't match.")
            return render(request, 'registration/reset_password.html', {'token': token})

        if len(new_password1) < 12: # Enforce your password policy
             messages.error(request, "Password must be at least 12 characters long.")
             return render(request, 'registration/reset_password.html', {'token': token})

        # Use Django's password validation (recommended)
        from django.contrib.auth.password_validation import validate_password
        try:
            validate_password(new_password1, user)
        except Exception as e:
             messages.error(request, f"Password error: {', '.join(e.messages)}")
             return render(request, 'registration/reset_password.html', {'token': token})

        # All checks passed, set the new password
        try:
            with transaction.atomic():
                user.set_password(new_password1) # Hashes the password
                user.reset_token = None
                user.reset_token_expires_at = None
                user.save(update_fields=['password', 'reset_token', 'reset_token_expires_at'])
                messages.success(request, "Your password has been reset successfully. You can now log in.")
                logger.info(f"Password reset successfully for user: {user.username}")
        except Exception as e:
             messages.error(request, "An error occurred while resetting your password. Please try again.")
             logger.error(f"Error resetting password for user {user.username}: {e}")

        return redirect('login')

    # Handle GET request (show the reset form)
    return render(request, 'registration/reset_password.html', {'token': token})

class LoginView(View):
    template_name = 'registration/login.html'
    
    def get(self, request):
        if request.user.is_authenticated:
            return redirect('dashboard')  # Change to your dashboard URL
        form = SecureAuthenticationForm()
        return render(request, self.template_name, {'form': form})
    
    def post(self, request):
        form = SecureAuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            
            # Log successful login
            logger.info(f"Successful login for user: {user.username} from IP: {get_client_ip(request)}")
            
            # Redirect to next page or dashboard
            next_page = request.GET.get('next', '/dashboard/')  # Change to your dashboard URL
            return redirect(next_page)
        else:
            # Log failed login attempt
            username = request.POST.get('username')
            logger.warning(f"Failed login attempt for user: {username} from IP: {get_client_ip(request)}")
            
        return render(request, self.template_name, {'form': form})

def get_client_ip(request):
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip

@method_decorator([csrf_protect, never_cache], name='dispatch')
class RegisterView(View):
    template_name = 'registration/register.html'
    
    def get(self, request):
        if request.user.is_authenticated:
            return redirect('dashboard')
        form = SecureUserCreationForm()
        return render(request, self.template_name, {'form': form})
    
    def post(self, request):
        form = SecureUserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            messages.success(request, 'Registration successful. Please log in.')
            logger.info(f"New user registered: {user.username}")
            return redirect('login')
        return render(request, self.template_name, {'form': form})

@login_required
def logout_view(request):
    logout(request)
    messages.info(request, 'You have been logged out successfully.')
    return redirect('login')

@login_required
def home(request):
    print(f"User is authenticated: {request.user.is_authenticated}")  # Debug statement
    # Generate last 12 months (including current month)
    today = date.today()
    months = []
    
    # Create list of last 12 months
    for i in range(11, -1, -1):  # 11 down to 0
        month_date = today - relativedelta(months=i)
        months.append({
            'year': month_date.year,
            'month': month_date.month,
            'month_name': calendar.month_abbr[month_date.month],
            'full_date': month_date  # We'll use this for calculations
        })
    
    # Calculate income and expenses for each month
    income_data = []
    expense_data = []
    month_labels = []
    
    for month_info in months:
        year = month_info['year']
        month = month_info['month']
        month_labels.append(f"{month_info['month_name']} {year}")

        # Correct way to call the functions:
        income = calculate_monthly_income(year, month)  # Pass only year and month
        income_data.append(float(income))

        expenses = calculate_monthly_expenses(year, month) # Pass only year and month
        expense_data.append(float(expenses))
    
    # Calculate summary metrics
    total_income = sum(property_obj.calculate_total_income() for property_obj in Property.objects.all())
    total_expenses = sum(property_obj.calculate_total_expenses() for property_obj in Property.objects.all())
    net_profit_loss = total_income - total_expenses
    
    context = {
        'months': month_labels,
        'income_data': income_data,
        'expense_data': expense_data,
        'total_income': total_income,
        'total_expenses': total_expenses,
        'net_profit_loss': net_profit_loss,
    }
    
    return render(request, 'home.html', context)

@login_required
def properties(request):
    # Get all properties
    all_properties = Property.objects.all().order_by('-purchase_date')
    
    # Prepare data for the template
    properties_with_financials = []
    for property_obj in all_properties:
        prop_data = {
            'property': property_obj,
            'total_income': property_obj.calculate_total_income(),
            'total_expenses': property_obj.calculate_total_expenses(),
            'net_income': property_obj.calculate_net_income(),
        }
        properties_with_financials.append(prop_data)
    
    context = {
        'properties': properties_with_financials
    }
    
    return render(request, 'property/properties.html', context)

@login_required
def add_property(request):
    if request.method == 'POST':
        form = PropertyForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Property added successfully!')
            return redirect('properties')
    else:
        form = PropertyForm()
    
    return render(request, 'property/add_property.html', {'form': form})

def calculate_monthly_income(year, month):
    
    total_income = Decimal('0.00')
    today = date.today()
    
    # Determine the actual end date for the calculation period
    # If we are calculating for the current month/year, use today's date
    # Otherwise, use the last day of the specified month
    if year == today.year and month == today.month:
        end_of_calculation_period = today
    else:
        end_of_calculation_period = date(year, month, calendar.monthrange(year, month)[1])
    
    # Define the start of the month being calculated
    start_of_month = date(year, month, 1)

    # Get all properties
    properties = Property.objects.all()
    
    # Add base rental income for properties that were owned during this month
    for property_obj in properties:
        # Check if property was owned during this month (at least partially)
        # Property must have been purchased before or during the month being calculated
        if property_obj.purchase_date <= end_of_calculation_period and \
           (property_obj.purchase_date.year < year or 
            (property_obj.purchase_date.year == year and property_obj.purchase_date.month <= month)):
            
            # For rental and owned_outright properties, calculate tenant income
            if property_obj.property_type in ['rental', 'owned_outright']:
                
                # Iterate through all tenants for this property
                for tenant in property_obj.tenant_set.all():
                    # --- Check if the tenant was active during (part of) this calculation period ---
                    
                    # Tenant's rental period starts on move_in_date
                    tenant_start = tenant.move_in_date
                    
                    # Tenant's rental period ends on the day BEFORE move_out_date, or is ongoing (None)
                    # If ongoing, consider it up to the end of our calculation period (today or end of month)
                    if tenant.move_out_date:
                        # Tenant's income stops the day before they move out
                        tenant_end = tenant.move_out_date - timedelta(days=1)
                    else:
                        # Tenant is still active, income continues until our calculation period ends
                        tenant_end = end_of_calculation_period

                    # --- Find the overlap between the calculation period and the tenant's stay ---
                    
                    # The income period for this tenant in this month is the later of:
                    #   - The start of the month being calculated
                    #   - The tenant's move-in date
                    income_period_start = max(start_of_month, tenant_start)
                    
                    # The income period for this tenant in this month is the earlier of:
                    #   - The end of our calculation period (today if current month, else end of month)
                    #   - The tenant's adjusted move-out date (or end of calculation period if still active)
                    income_period_end = min(end_of_calculation_period, tenant_end)

                    # --- Calculate income if there is a positive overlapping period ---
                    # Check if the income period is valid (start is not after end)
                    if income_period_start <= income_period_end:
                        # Calculate the number of days the tenant was active in this period (earning rent)
                        days_active = (income_period_end - income_period_start).days + 1 # +1 because both start and end dates count as full days of income
                        
                        if days_active > 0 and tenant.weekly_rent > 0:
                            # Calculate daily rent based on the tenant's weekly rent
                            daily_rent = Decimal(str(tenant.weekly_rent)) / Decimal('7')
                            # Add the income for this tenant during this period
                            income_for_tenant_period = daily_rent * days_active
                            total_income += income_for_tenant_period
                            
                            # Debug prints
                            print(f"Property: {property_obj.address}")
                            print(f"  Tenant ID: {tenant.id}")
                            print(f"    Move-In Date: {tenant.move_in_date}")
                            print(f"    Move-Out Date: {tenant.move_out_date}")
                            print(f"    Adjusted Tenant End Date (last income day): {tenant_end}")
                            print(f"    Calculation Period Start: {start_of_month}")
                            print(f"    Calculation Period End: {end_of_calculation_period}")
                            print(f"    Income Period Start: {income_period_start}")
                            print(f"    Income Period End: {income_period_end}")
                            print(f"    Days Active (earning rent): {days_active}")
                            print(f"    Weekly Rent: ${tenant.weekly_rent}")
                            print(f"    Daily Rent: ${daily_rent}")
                            print(f"    Income for Tenant: ${income_for_tenant_period}")
                            print(f"  Total Income So Far: ${total_income}\n")

    # --- Add transaction-based income for this specific month ---
    month_income_result = Transaction.objects.filter(
        date__year=year,
        date__month=month,
        transaction_type__in=['rental_income', 'additional_income', 'other_income']
    ).aggregate(Sum('amount'))['amount__sum']
    
    month_income = month_income_result or Decimal('0.00')
    
    total_income += month_income
    
    # Debug print for final total income
    print(f"Final Total Monthly Income for {year}-{month:02d} (up to {end_of_calculation_period}): ${total_income}")
    
    return float(total_income)

def calculate_monthly_expenses(year, month):
    
    total_expenses = Decimal('0.00')
    
    # Get all properties
    properties = Property.objects.all()
    
    # Add base mortgage expenses for properties that were owned during this month
    # EXCEPT for owned_outright properties (they don't have mortgages)
    for property_obj in properties:
        # Check if property was owned during this month
        if property_obj.purchase_date.year < year or (property_obj.purchase_date.year == year and property_obj.purchase_date.month <= month):
            # Add weekly mortgage converted to monthly for properties that are NOT owned_outright
            if property_obj.property_type != 'owned_outright' and property_obj.weekly_mortgage > 0:
                # Calculate accurate monthly mortgage based on days in the month
                days_in_month = calendar.monthrange(year, month)[1]
                start_date = date(year, month, 1)
                end_date = date(year, month, days_in_month)
                
                # Exclude the purchase week
                first_payday = property_obj.purchase_date + timedelta(days=(4 - property_obj.purchase_date.weekday()))
                if first_payday <= end_date:
                    start_date = max(first_payday, property_obj.tenant_move_in_date or start_date)
                    end_date = min(end_date, property_obj.tenant_move_out_date or end_date)
                    
                    # Calculate number of days owned in the month
                    days_owned = (end_date - start_date).days + 1
                    
                    if days_owned > 0:
                        # Calculate daily mortgage
                        daily_mortgage = Decimal(str(property_obj.weekly_mortgage)) / Decimal('7')
                        total_expenses += daily_mortgage * days_owned
                        print(f"Expense for {year}-{month}: ${total_expenses}")
    
    # Add transaction-based expenses for this specific month
    month_expenses_result = Transaction.objects.filter(
        date__year=year,
        date__month=month,
        transaction_type__in=['maintenance', 'taxes', 'insurance', 'other_expense']
    ).aggregate(Sum('amount'))['amount__sum']
    
    month_expenses = month_expenses_result or Decimal('0.00')
    
    total_expenses += month_expenses
    return float(total_expenses)

@login_required
def add_tenant(request, property_id):
    property_obj = get_object_or_404(Property, id=property_id)
    
    # Prevent adding tenants to owner-occupied properties
    if property_obj.property_type == 'owner_occupied':
        messages.error(request, "Cannot add tenants to an owner-occupied property.")
        # Redirect back to the property detail page or properties list
        return redirect('property_detail', property_id=property_id) # Or 'properties' if no detail view
        
    if request.method == 'POST':
        form = TenantForm(request.POST)
        if form.is_valid():
            # Get the latest tenant for this property who doesn't have a move_out_date
            latest_tenant = property_obj.tenant_set.filter(move_out_date__isnull=True).order_by('-move_in_date').first()
            
            # If there's a previous tenant, set their move_out_date to one day before new tenant's move_in_date
            if latest_tenant:
                new_tenant_move_in = form.cleaned_data['move_in_date']
                from django.utils import timezone
                latest_tenant.move_out_date = new_tenant_move_in - timezone.timedelta(days=1)
                latest_tenant.save()
                messages.info(request, f"Previous tenant's stay marked as ended on {latest_tenant.move_out_date}")
            
            # Save the new tenant
            tenant = form.save(commit=False)
            tenant.property = property_obj
            tenant.save()
            messages.success(request, "Tenant added successfully.")
            return redirect('property_detail', property_id=property_id) # Or wherever appropriate
    else:
        form = TenantForm()
    
    return render(request, 'tenants/add_tenant.html', {'form': form, 'property': property_obj})

@login_required
def edit_tenant(request, tenant_id):
    tenant = get_object_or_404(Tenant, id=tenant_id)
    property_obj = tenant.property
    
    if request.method == 'POST':
        form = TenantForm(request.POST, instance=tenant)
        if form.is_valid():
            form.save()
            messages.success(request, "Tenant updated successfully.")
            return redirect('property_detail', property_id=property_obj.id)
    else:
        form = TenantForm(instance=tenant)
    
    return render(request, 'tenants/edit_tenant.html', {'form': form, 'property': property_obj})

@login_required
def delete_tenant(request, tenant_id):
    tenant = get_object_or_404(Tenant, id=tenant_id)
    property_obj = tenant.property # Get the related property object

    if request.method == 'POST':
        tenant.delete()
        messages.success(request, "Tenant deleted successfully.")
        # Redirect to the property detail page after deletion
        return redirect('property_detail', property_id=property_obj.id)

    # For GET request, render the confirmation page
    # Pass both the tenant and the property object to the template context
    return render(request, 'tenants/delete_tenant.html', { 'tenant': tenant, 'property': property_obj })

@login_required
def add_transaction(request):
    if request.method == 'POST':
        form = TransactionForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Transaction added successfully!')
            return redirect('properties')  # Changed from 'transaction_log' to 'properties'
    else:
        form = TransactionForm()
        # Pre-select property if provided in URL
        property_id = request.GET.get('property')
        if property_id:
            form.fields['property'].initial = property_id
    
    return render(request, 'transactions/add_transaction.html', {'form': form})

@login_required
def add_bulk_transaction(request):
    if request.method == 'POST':
        form = BulkTransactionForm(request.POST)
        if form.is_valid():
            properties = form.cleaned_data['properties']  # This is a QuerySet
            date_val = form.cleaned_data['date']
            amount = form.cleaned_data['amount']
            transaction_type = form.cleaned_data['transaction_type']
            description = form.cleaned_data['description']
            
            # Create transactions for each selected property
            created_count = 0
            for property_obj in properties:
                Transaction.objects.create(
                    property=property_obj,
                    date=date_val,
                    amount=amount,
                    transaction_type=transaction_type,
                    description=description
                )
                created_count += 1
            
            messages.success(request, f'Transaction added to {created_count} properties successfully!')
            return redirect('transaction_log')  # Redirect to transaction log instead of properties
    else:
        form = BulkTransactionForm()
    
    # Pass the properties queryset to the template for better control if needed
    properties_for_template = Property.objects.all().order_by('address')
    
    return render(request, 'transactions/add_bulk_transaction.html', { 'form': form, 'properties': properties_for_template })

@login_required
def property_detail(request, property_id):
    property_obj = get_object_or_404(Property, id=property_id)
    
    # Get transactions for this property
    transactions = Transaction.objects.filter(property=property_obj).order_by('-date')
    
    # Calculate financial summary for this property USING THE MODEL METHODS
    total_income = property_obj.calculate_total_income()  # Call method on the instance
    total_expenses = property_obj.calculate_total_expenses()  # Call method on the instance
    net_income = property_obj.calculate_net_income()  # Call method on the instance
    
    context = {
        'property': property_obj,
        'transactions': transactions,
        'total_income': total_income,
        'total_expenses': total_expenses,
        'net_income': net_income,
    }
    
    return render(request, 'property/property_detail.html', context)

@login_required
def transaction_log(request):
    # Get all transactions, ordered by date (newest first)
    transactions = Transaction.objects.select_related('property').order_by('-date', '-created_at')
    
    # Optional: Add filtering capabilities
    transaction_type = request.GET.get('type')
    property_id = request.GET.get('property')
    
    if transaction_type:
        transactions = transactions.filter(transaction_type=transaction_type)
    
    if property_id:
        transactions = transactions.filter(property_id=property_id)
    
    # Get properties for filter dropdown
    properties = Property.objects.all().order_by('address')
    
    # Calculate summary statistics
    
    # Get filtered transactions for summary (we need to re-filter the base queryset for accurate sums)
    filtered_transactions = Transaction.objects.all()
    if transaction_type:
        filtered_transactions = filtered_transactions.filter(transaction_type=transaction_type)
    if property_id:
        filtered_transactions = filtered_transactions.filter(property_id=property_id)
    
    # Calculate income and expenses
    income_transactions = filtered_transactions.filter(
        transaction_type__in=['rental_income', 'additional_income', 'other_income']
    )
    expense_transactions = filtered_transactions.filter(
        transaction_type__in=['maintenance', 'taxes', 'insurance', 'other_expense']
    )
    
    total_income = income_transactions.aggregate(sum=Sum('amount'))['sum'] or 0
    total_expenses = expense_transactions.aggregate(sum=Sum('amount'))['sum'] or 0
    net_amount = total_income - total_expenses
    
    context = {
        'transactions': transactions,
        'properties': properties,
        'selected_type': transaction_type,
        'selected_property': property_id,
        'transaction_type_choices': TRANSACTION_TYPE_CHOICES,
        'total_income': total_income,
        'total_expenses': total_expenses,
        'net_amount': net_amount,
        'total_transactions': transactions.count(),
    }
    
    return render(request, 'transactions/transaction_log.html', context)

@login_required
def edit_property(request, property_id):
    property_obj = get_object_or_404(Property, id=property_id)
    
    if request.method == 'POST':
        if 'delete' in request.POST:
            # Handle property deletion
            property_address = property_obj.address
            property_obj.delete()
            messages.success(request, f'Property "{property_address}" has been deleted successfully!')
            return redirect('properties')
        else:
            # Handle property update
            form = PropertyForm(request.POST, instance=property_obj)
            if form.is_valid():
                form.save()
                messages.success(request, 'Property updated successfully!')
                return redirect('property_detail', property_id=property_obj.id)
            else:
                messages.error(request, 'Please correct the errors below.')
    else:
        form = PropertyForm(instance=property_obj)
    
    # Calculate financial data using model methods
    total_income = property_obj.calculate_total_income()
    total_expenses = property_obj.calculate_total_expenses()
    net_income = property_obj.calculate_net_income()
    transaction_count = property_obj.transaction_set.count()
    
    context = {
        'form': form,
        'property': property_obj,
        'total_income': total_income,
        'total_expenses': total_expenses,
        'net_income': net_income,
        'transaction_count': transaction_count,
    }
    
    return render(request, 'property/edit_property.html', context)

def calculate_predicted_value(self, years_ahead=5, annual_growth_rate=0.03):
    """Calculate predicted value based on simple growth rate"""
    if not self.purchase_price:
        return 0
    
    from datetime import date
    current_year = date.today().year
    years_owned = current_year - self.purchase_date.year
    total_years = years_owned + years_ahead
    
    # Simple compound growth
    predicted_value = float(self.purchase_price) * ((1 + annual_growth_rate) ** total_years)
    return round(predicted_value, 2)

@login_required
def tools_home(request):
    """Main tools page"""
    properties = Property.objects.all()
    context = {
        'properties': properties
    }
    return render(request, 'tools/tools_home.html', context)

@login_required
def property_value_calculator(request):
    """Property value prediction calculator"""
    if request.method == 'POST':
        # Check if user wants to clear the projection
        if 'clear_projection' in request.POST:
            # Clear the session or redirect to clean state
            return redirect('value_calculator')
        
        form = ValuePredictionForm(request.POST)
        if form.is_valid():
            property_obj = form.cleaned_data['property']
            years_ahead = form.cleaned_data['years_ahead']
            growth_rate = form.cleaned_data['annual_growth_rate'] / 100  # Convert percentage to decimal
            scenario_name = form.cleaned_data['scenario_name'] or f"{growth_rate*100}% Growth Scenario"
            
            # Calculate values
            current_value = property_obj.calculate_current_value(growth_rate)
            future_value = property_obj.calculate_future_value(years_ahead, growth_rate)
            roi = property_obj.calculate_roi(growth_rate)
            value_history = property_obj.get_value_history(5, growth_rate)
            
            context = {
                'form': form,
                'property': property_obj,
                'years_ahead': years_ahead,
                'growth_rate': growth_rate * 100,
                'scenario_name': scenario_name,
                'current_value': current_value,
                'future_value': future_value,
                'roi': roi,
                'value_history': value_history,
                'show_results': True
            }
        else:
            context = {'form': form}
    else:
        form = ValuePredictionForm()
        context = {'form': form}
    
    return render(request, 'tools/value_calculator.html', context)

@login_required
def add_scenario(request):
    if request.method == 'POST':
        form = ScenarioForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Scenario added successfully!')
            return redirect('scenario_list')
    else:
        form = ScenarioForm()
    
    return render(request, 'tools/add_scenario.html', {'form': form})

@login_required
def scenario_list(request):
    scenarios = Scenario.objects.all().order_by('-created_at')
    return render(request, 'tools/scenario_list.html', {'scenarios': scenarios})

@login_required
def delete_scenario(request, scenario_id):
    scenario = get_object_or_404(Scenario, id=scenario_id)
    if request.method == 'POST':
        scenario_name = scenario.name
        scenario.delete()
        messages.success(request, f'Scenario "{scenario_name}" deleted successfully!')
        return redirect('scenario_list')
    return render(request, 'tools/delete_scenario.html', {'scenario': scenario})

@login_required
def scenario_comparison(request):
    if request.method == 'POST':
        form = ScenarioComparisonForm(request.POST)
        if form.is_valid():
            property_obj = form.cleaned_data['property']
            years_ahead = form.cleaned_data['years_ahead']
            selected_scenarios = form.cleaned_data['scenarios']
            
            # Calculate values for each scenario
            results = []
            for scenario in selected_scenarios:
                growth_rate = float(scenario.growth_rate) / 100
                current_value = property_obj.calculate_current_value(growth_rate)
                future_value = property_obj.calculate_future_value(years_ahead, growth_rate)
                roi = property_obj.calculate_roi(growth_rate)
                
                results.append({
                    'scenario': scenario,
                    'current_value': current_value,
                    'future_value': future_value,
                    'roi': roi,
                })
            
            context = {
                'form': form,
                'results': results,
                'property': property_obj,
                'years_ahead': years_ahead,
                'show_results': True
            }
        else:
            context = {'form': form}
    else:
        form = ScenarioComparisonForm()
        context = {'form': form}
    
    return render(request, 'tools/scenario_comparison.html', context)

@login_required
def trend_tracking(request):
    """Trend tracking and comparison tool"""
    properties = Property.objects.filter(purchase_price__isnull=False).exclude(purchase_price=0)
    
    # Calculate portfolio trends
    portfolio_data = []
    total_investment = 0
    total_current_value = 0
    
    for property_obj in properties:
        current_value = property_obj.calculate_current_value(0.03)  # Default 3% growth
        roi = property_obj.calculate_roi(0.03)
        purchase_price = float(property_obj.purchase_price)
        
        # Calculate value change (this is what was causing issues in the template)
        value_change = current_value - purchase_price
        
        portfolio_data.append({
            'property': property_obj,
            'current_value': current_value,
            'roi': roi,
            'purchase_price': purchase_price,
            'value_change': value_change  # Add this calculated value
        })
        
        total_investment += purchase_price
        total_current_value += current_value
    
    # Portfolio summary
    portfolio_roi = 0
    if total_investment > 0:
        portfolio_roi = ((total_current_value - total_investment) / total_investment) * 100
    
    context = {
        'properties': properties,
        'portfolio_data': portfolio_data,
        'total_investment': total_investment,
        'total_current_value': total_current_value,
        'portfolio_roi': round(portfolio_roi, 2)
    }
    
    return render(request, 'tools/trend_tracking.html', context)

@login_required
def edit_transaction(request, transaction_id):
    transaction_obj = get_object_or_404(Transaction, id=transaction_id)
    
    if request.method == 'POST':
        if 'delete' in request.POST:
            # Handle transaction deletion
            transaction_description = transaction_obj.description or f"{transaction_obj.get_transaction_type_display()} transaction"
            property_address = transaction_obj.property.address if transaction_obj.property else "No Property"
            transaction_obj.delete()
            messages.success(request, f'Transaction "{transaction_description}" for {property_address} has been deleted successfully!')
            return redirect('transaction_log')
        else:
            # Handle transaction update
            form = TransactionForm(request.POST, instance=transaction_obj)
            if form.is_valid():
                form.save()
                messages.success(request, 'Transaction updated successfully!')
                return redirect('transaction_log')
            else:
                messages.error(request, 'Please correct the errors below.')
    else:
        form = TransactionForm(instance=transaction_obj)
    
    context = {
        'form': form,
        'transaction': transaction_obj,
    }
    
    return render(request, 'transactions/edit_transaction.html', context)

@login_required
def tax_summary(request):
    from datetime import date
    from decimal import Decimal
    print("========== DEBUG: tax_summary view started ==========")
    # Get all properties for the current user
    properties = Property.objects.all().order_by('purchase_date')
    print(f"DEBUG: Found {properties.count()} properties")
    # Calculate current financial year
    today = date.today()
    if today.month >= 7:  # If current month is July or later
        financial_year = today.year
    else:  # If current month is before July
        financial_year = today.year - 1
    # Calculate date range for current financial year (July 1 to today)
    financial_year_start = date(financial_year, 7, 1)
    financial_year_end = today  # Only up to today, not end of financial year
    print(f"DEBUG: Financial Year: {financial_year}")
    print(f"DEBUG: Period Start: {financial_year_start}")
    print(f"DEBUG: Period End (Today): {financial_year_end}")
    
    # Prepare property data with actual earnings/spending so far
    property_tax_data = []
    total_income = Decimal('0.00')
    total_expenses = Decimal('0.00')
    for property_obj in properties:
        print(f"--- DEBUG: Processing Property: {property_obj.address} (ID: {property_obj.id}) ---")
        # Calculate income for period from start of financial year to today
        property_income = calculate_actual_income(property_obj, financial_year_start, financial_year_end)
        # Calculate expenses for period from start of financial year to today
        property_expenses = calculate_actual_expenses(property_obj, financial_year_start, financial_year_end)
        # Calculate pro-rated depreciation
        depreciation = calculate_pro_rata_depreciation(property_obj, financial_year_start, financial_year_end)
        # Net income for this property (exclude depreciation)
        net_income = property_income - property_expenses
        print(f"DEBUG:   Property Income: {property_income}")
        print(f"DEBUG:   Property Expenses: {property_expenses}")
        print(f"DEBUG:   Property Depreciation: {depreciation}")
        print(f"DEBUG:   Property Net Income (w/o dep): {net_income}")
        
        # Filter transactions for the property within the date range
        property_transactions = Transaction.objects.filter(
            property=property_obj,
            date__gte=financial_year_start,
            date__lte=financial_year_end
        ).order_by('date')
        
        print(f"  DEBUG:   Found {property_transactions.count()} transactions for {property_obj.address} within {financial_year_start} to {financial_year_end}")
        for t in property_transactions:
            print(f"  DEBUG:     Transaction ID {t.id}: {t.date}, {t.get_transaction_type_display()}, ${t.amount}")

        property_tax_data.append({
            'property': property_obj,
            'income': property_income,
            'expenses': property_expenses,
            'depreciation': depreciation,
            'net_income': net_income,
            'transactions': property_transactions  # Add transactions to the context
        })
        total_income += property_income
        total_expenses += property_expenses
    
    # Calculate total depreciation
    total_depreciation = sum(item['depreciation'] for item in property_tax_data)
    # Overall net income (exclude depreciation)
    overall_net_income = total_income - total_expenses
    
    print(f"========== DEBUG: Final Summary ==========")
    print(f"DEBUG: Total Income: {total_income}")
    print(f"DEBUG: Total Expenses: {total_expenses}")
    print(f"DEBUG: Total Depreciation: {total_depreciation}")
    print(f"DEBUG: Overall Net Income (w/o dep): {overall_net_income}")
    print("========== DEBUG: tax_summary view finished ==========")
    
    context = {
        'properties_data': property_tax_data,
        'financial_year': financial_year,
        'financial_year_display': f"{financial_year}-{financial_year + 1}",
        'period_start': financial_year_start,
        'period_end': financial_year_end,
        'total_income': total_income,
        'total_expenses': total_expenses,
        'total_depreciation': total_depreciation,
        'overall_net_income': overall_net_income,
        'generated_date': date.today()
    }
    return render(request, 'tax_summary.html', context)

def calculate_actual_income(property_obj, start_date, end_date):
    """Calculate actual income earned from start_date to end_date"""
    from decimal import Decimal
    print(f"  DEBUG:   --> calculate_actual_income for '{property_obj.address}' (ID: {property_obj.id})")
    print(f"  DEBUG:       Period: {start_date} to {end_date}")
    total_income = Decimal('0.00')

    # Calculate tenant income for the actual period
    tenant_income = Decimal('0.00')
    print(f"  DEBUG:       Checking {property_obj.tenant_set.count()} tenants...")
    for tenant in property_obj.tenant_set.all():
        print(f"  DEBUG:         Tenant ID {tenant.id}: Move-in {tenant.move_in_date}, Move-out {tenant.move_out_date}, Rent {tenant.weekly_rent}/wk")
        # Determine tenant's active period during our calculation period
        tenant_start = max(start_date, tenant.move_in_date)

        if tenant.move_out_date:
            tenant_end = min(end_date, tenant.move_out_date)
        else:
            tenant_end = end_date

        # Calculate overlapping period
        if tenant_start <= tenant_end:
            # Calculate days active
            days_active = (tenant_end - tenant_start).days + 1

            if days_active > 0 and tenant.weekly_rent > 0:
                # Calculate daily rent
                daily_rent = Decimal(str(tenant.weekly_rent)) / Decimal('7')
                income_for_period = daily_rent * days_active
                tenant_income += income_for_period
                print(f"  DEBUG:           -> Active {days_active} days, Income: {income_for_period}")
        else:
             print(f"  DEBUG:           -> No overlap with period, skipping.")

    # Add transaction-based income for the actual period
    income_transactions_queryset = Transaction.objects.filter(
        property=property_obj,
        date__gte=start_date,
        date__lte=end_date,
        transaction_type__in=['rental_income', 'additional_income', 'other_income']
    )
    print(f"  DEBUG:       Checking {income_transactions_queryset.count()} income transactions...")
    for t in income_transactions_queryset:
         print(f"  DEBUG:         Transaction ID {t.id}: {t.date}, {t.get_transaction_type_display()}, ${t.amount}")

    transaction_income_result = income_transactions_queryset.aggregate(Sum('amount'))
    transaction_income = transaction_income_result['amount__sum'] or Decimal('0.00')

    total_income = tenant_income + transaction_income
    print(f"  DEBUG:   <-- calculate_actual_income result: {total_income} (Tenant: {tenant_income} + Transaction: {transaction_income})")
    return total_income

def calculate_actual_expenses(property_obj, start_date, end_date):
    """Calculate actual expenses incurred from start_date to end_date"""
    from decimal import Decimal
    print(f"  DEBUG:   --> calculate_actual_expenses for '{property_obj.address}' (ID: {property_obj.id})")
    print(f"  DEBUG:       Period: {start_date} to {end_date}")
    total_expenses = Decimal('0.00')

    # Calculate mortgage expenses for the actual period
    mortgage_expenses = Decimal('0.00')
    if property_obj.property_type != 'owned_outright' and property_obj.weekly_mortgage and property_obj.weekly_mortgage > 0:
        # Calculate days owned during our calculation period
        property_start = max(start_date, property_obj.purchase_date)
        property_end = end_date  # Only up to today
        print(f"  DEBUG:       Property purchased {property_obj.purchase_date}. Relevant ownership period: {property_start} to {property_end}")

        if property_start <= property_end:
            days_owned = (property_end - property_start).days + 1
            daily_mortgage = Decimal(str(property_obj.weekly_mortgage)) / Decimal('7')
            mortgage_expenses = daily_mortgage * days_owned
            print(f"  DEBUG:         -> Owned for {days_owned} days, Mortgage: {property_obj.weekly_mortgage}/wk, Expense: {mortgage_expenses}")
        else:
             print(f"  DEBUG:         -> No ownership overlap with period, no mortgage expense.")
    else:
        print(f"  DEBUG:       Property is 'owned_outright' or has no mortgage, skipping mortgage calculation.")

    # Add transaction-based expenses for the actual period
    expense_transactions_queryset = Transaction.objects.filter(
        property=property_obj,
        date__gte=start_date,
        date__lte=end_date,
        transaction_type__in=['maintenance', 'taxes', 'insurance', 'other_expense']
    )
    print(f"  DEBUG:       Checking {expense_transactions_queryset.count()} expense transactions...")
    for t in expense_transactions_queryset:
         print(f"  DEBUG:         Transaction ID {t.id}: {t.date}, {t.get_transaction_type_display()}, ${t.amount}")

    transaction_expenses_result = expense_transactions_queryset.aggregate(Sum('amount'))
    transaction_expenses = transaction_expenses_result['amount__sum'] or Decimal('0.00')

    total_expenses = mortgage_expenses + transaction_expenses
    print(f"  DEBUG:   <-- calculate_actual_expenses result: {total_expenses} (Mortgage: {mortgage_expenses} + Transaction: {transaction_expenses})")
    return total_expenses

def calculate_pro_rata_depreciation(property_obj, start_date, end_date):
    """Calculate pro-rated depreciation for the period from start_date to end_date"""
    from decimal import Decimal
    print(f"  DEBUG:   --> calculate_pro_rata_depreciation for '{property_obj.address}' (ID: {property_obj.id})")
    if property_obj.property_type == 'rental' and property_obj.purchase_price:
        # Calculate annual depreciation
        annual_depreciation = Decimal(str(property_obj.purchase_price)) / Decimal('27.5')
        # Calculate the number of days in our period
        period_days = (end_date - start_date).days + 1
        # Calculate pro-rated depreciation (365 days in a year for simplicity)
        pro_rata_depreciation = (annual_depreciation / Decimal('365')) * Decimal(str(period_days))
        print(f"  DEBUG:       Purchase Price: {property_obj.purchase_price}, Annual Depreciation: {annual_depreciation}, Period Days: {period_days}, Pro-rated: {pro_rata_depreciation}")
        print(f"  DEBUG:   <-- calculate_pro_rata_depreciation result: {pro_rata_depreciation}")
        return pro_rata_depreciation
    print(f"  DEBUG:       Not rental property or no purchase price, returning 0.00")
    print(f"  DEBUG:   <-- calculate_pro_rata_depreciation result: 0.00")
    return Decimal('0.00')